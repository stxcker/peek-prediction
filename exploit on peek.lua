-- [x]====================[ UI References ]====================[x]
local doubletap = ui.reference( "Rage", "Other", "Double tap" )
local onshot = ui.reference( "AA", "Other", "On shot anti-aim" )
local limit = ui.reference( "AA", "Fake lag", "Limit" )

-- [x]=======================================[ UI Additions ]=======================================[x]
local onpeek = ui.new_combobox( "AA", "Other", "On peek", { "Off", "Double tap", "On shot anti-aim", "Fake lag" } )

-- [x]============[ Data Structures ]============[x]
local function vec_3( _x, _y, _z ) 
	return { x = _x or 0, y = _y or 0, z = _z or 0 } 
end

-- [x]=============[ Math ]=============[x]
local function ticks_to_time( ticks )
	return globals.tickinterval( ) * ticks
end 

-- [x]==============================================================================================================[ Local Functions ]==============================================================================================================[x]
local function player_will_peek( )
	local enemies = entity.get_players( true )
	if not enemies then
		return false
	end
	
	-- Predict the local player's eye
	local predicted = 0
	if ui.get( onpeek ) == "Double tap" then
		predicted = 11
	elseif ui.get( onpeek ) == "On shot anti-aim" then
		predicted = 6
	elseif ui.get( onpeek ) == "Fake lag" then
		predicted = 14
	end
	local eye_position = vec_3( client.eye_position( ) )
	local velocity_prop_local = vec_3( entity.get_prop( entity.get_local_player( ), "m_vecVelocity" ) )
	local predicted_eye_position = vec_3( eye_position.x + velocity_prop_local.x * ticks_to_time( predicted ), eye_position.y + velocity_prop_local.y * ticks_to_time( predicted ), eye_position.z + velocity_prop_local.z * ticks_to_time( predicted ) )

	for i = 1, #enemies do
		local player = enemies[ i ]
		
		local velocity_prop = vec_3( entity.get_prop( player, "m_vecVelocity" ) )
		
		-- Store and predict player origin
		local origin = vec_3( entity.get_prop( player, "m_vecOrigin" ) )
		local predicted_origin = vec_3( origin.x + velocity_prop.x * ticks_to_time( 16 ), origin.y + velocity_prop.y * ticks_to_time( 16 ), origin.z + velocity_prop.z * ticks_to_time( 16 ) )
		
		-- Set their origin to their predicted origin so we can run calculations on it
		entity.get_prop( player, "m_vecOrigin", predicted_origin )
		
		-- Predict their head position and fire an autowall trace to see if any damage can be dealt
		local head_origin = vec_3( entity.hitbox_position( player, 0 ) )
		local predicted_head_origin = vec_3( head_origin.x + velocity_prop.x * ticks_to_time( 16 ), head_origin.y + velocity_prop.y * ticks_to_time( 16 ), head_origin.z + velocity_prop.z * ticks_to_time( 16 ) )
		local trace_entity, damage = client.trace_bullet( entity.get_local_player( ), predicted_eye_position.x, predicted_eye_position.y, predicted_eye_position.z, predicted_head_origin.x, predicted_head_origin.y, predicted_head_origin.z )
		
		-- Restore their origin to their networked origin
		entity.get_prop( player, "m_vecOrigin", origin )
		
		-- Check if damage can be dealt to their predicted head
		if damage > 0 then
			return true
		end
	end
	
	return false
end

-- [x]======================[ Callbacks ]======================[x]
client.set_event_callback( "setup_command", function( cmd )
	if ui.get( onpeek ) == "Double tap" then
		ui.set( doubletap, player_will_peek( ) and true or false )
	elseif ui.get( onpeek ) == "On shot anti-aim" then
		ui.set( onshot, player_will_peek( ) and true or false )
	elseif ui.get( onpeek ) == "Fake lag" then
		ui.set( limit, player_will_peek( ) and 14 or 3 )
	end
end )